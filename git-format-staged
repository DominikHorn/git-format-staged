#!/usr/bin/env python
#
# Git command to transform staged files according to a command that accepts file
# content on stdin and produces output on stdout. This command is useful in
# combination with `git add -p` which allows you to stage specific changes in
# a file. This command runs a formatter on the file with staged changes while
# ignoring unstaged changes.
#
# Usage: git-format-staged [options] command
# Example: git-format-staged --glob='*.js' prettier --stdin
#
# Tested with Python 3.6 and Python 2.7.
#
# Original author: Jesse Hallett <jesse@sitr.us>
#
# Consider a project where you want all code formatted consistently. So you use
# a formatting command. (For example I use [prettier-standard][] in my
# Javascript projects.) You want to make sure that everyone working on the
# project runs the formatter, so you use a tool like [husky][] to install a git
# precommit hook. The naive way to write that hook would be to:
#
# - get a list of staged files
# - run the formatter on those files
# - run `git add` to stage the results of formatting
#
# The problem with that solution is it forces you to commit entire files. At
# worst this will lead to contributors to unwittingly committing changes. At
# best it disrupts workflow for contributors who use `git add -p`.
#
# git-format-staged tackles this problem by running the formatter on the staged
# version of the file. Staging changes to a file actually produces a new file
# that exists in the git object database. git-format-staged uses some git
# plumbing commands to feed that file content to your formatter. The command
# replaces file content in the git index, and does not touch the working copy of
# the file.
#
# [prettier-standard]: https://www.npmjs.com/package/prettier-standard
# [husky]: https://www.npmjs.com/package/husky
#

from __future__ import print_function
import argparse
import re
import subprocess
import sys

VERSION='1.0.0'

# `glob` selects files using a shell glob - e.g. `'*.js'`
def format_staged_files(command, glob, update_working_tree=False):
    try:
        output = subprocess.check_output([
            'git', 'diff-index',
            '--cached',
            '--diff-filter=AM', # select only file additions and modifications
            '--no-renames',
            'HEAD',
            glob
            ])
        for line in output.splitlines():
            entry = parse_diff(line.decode('utf-8'))
            if format_file_in_index(command, entry, update_working_tree=update_working_tree):
                print('Reformatted {} with {}'.format(entry['src_path'], ' '.join(command)), file=sys.stderr)
    except Exception as err:
        print(str(err), file=sys.stderr)
        exit(1)

# Run formatter on file in the git index. Creates a new git object with the
# result, and replaces the content of the file in the index with that object.
# Returns hash of the new object if formatting produced any changes.
def format_file_in_index(command, diff_entry, update_working_tree=False):
    orig_hash = diff_entry['dst_hash']
    new_hash = format_object(command, orig_hash)

    # If the new hash is the same then the formatter did not make any changes.
    if new_hash == orig_hash:
        return None

    replace_file_in_index(diff_entry, new_hash)

    if update_working_tree:
        try:
            patch_working_file(diff_entry['src_path'], orig_hash, new_hash)
        except Exception as err:
            # Errors patching working tree files are not fatal
            print('Warning: {}'.format(str(err)), file=sys.stderr)

    return new_hash


# Run formatter on a git blob identified by its hash. Writes output to a new git
# blob, and returns the hash of the new blob.
def format_object(command, object_hash):
    get_content = subprocess.Popen(
            ['git', 'cat-file', '-p', object_hash],
            stdout=subprocess.PIPE
            )
    format_content = subprocess.Popen(
            command,
            stdin=get_content.stdout,
            stdout=subprocess.PIPE
            )
    write_object = subprocess.Popen(
            ['git', 'hash-object', '-w', '--stdin'],
            stdin=format_content.stdout,
            stdout=subprocess.PIPE
            )

    get_content.stdout.close()
    format_content.stdout.close()

    if get_content.wait() != 0:
        raise ValueError('Error reading file content from object database: ' + object_hash)

    if format_content.wait() != 0:
        raise Exception('Error running formatter') # TODO: capture stderr from format command

    new_hash, err = write_object.communicate()

    if write_object.returncode != 0:
        raise Exception('Error writing formatted content to object database')

    return new_hash.decode('utf-8').rstrip()

def replace_file_in_index(diff_entry, new_object_hash):
    subprocess.check_call(['git', 'update-index',
        '--cacheinfo', '{},{},{}'.format(
            diff_entry['dst_mode'],
            new_object_hash,
            diff_entry['src_path']
            )])

def patch_working_file(path, orig_object_hash, new_object_hash):
    patch = subprocess.check_output(
            ['git', 'diff', orig_object_hash, new_object_hash]
            )

    # Substitute object hashes in patch header with path to working tree file
    patch_b = patch.replace(orig_object_hash.encode(), path.encode()).replace(new_object_hash.encode(), path.encode())

    apply_patch = subprocess.Popen(
            ['git', 'apply', '-'],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
            )

    output, err = apply_patch.communicate(input=patch_b)

    if apply_patch.returncode != 0:
        raise Exception('could not apply formatting changes to working tree file {}'.format(path))

# Format: src_mode dst_mode src_hash dst_hash status/score? src_path dst_path?
diff_pat = re.compile('^:(\d+) (\d+) ([a-f0-9]+) ([a-f0-9]+) ([A-Z])(\d+)?\t([^\t]+)(?:\t([^\t]+))?$')

# Parse output from `git diff-index`
def parse_diff(diff):
    m = diff_pat.match(diff)
    if not m:
        raise ValueError('Failed to parse diff-index line: ' + diff)
    return {
            'src_mode': unless_zeroed(m.group(1)),
            'dst_mode': unless_zeroed(m.group(2)),
            'src_hash': unless_zeroed(m.group(3)),
            'dst_hash': unless_zeroed(m.group(4)),
            'status': m.group(5),
            'score': int(m.group(6)) if m.group(6) else None,
            'src_path': m.group(7),
            'dst_path': m.group(8)
            }

zeroed_pat = re.compile('^0+$')

# Returns the argument unless the argument is a string of zeroes, in which case
# returns `None`
def unless_zeroed(s):
    return s if not zeroed_pat.match(s) else None

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            description='Transform staged files using a formatting command that accepts content via stdin and produces a result via stdout.\nExample: git-format-staged --glob "*.js" prettier --stdin'
            )
    parser.add_argument(
            '--glob',
            default='*',
            help='Format files matching this shell glob. For example *.js matches all files with the .js extension, or src/*.js matches .js files in src/ or its subdirectories. (Default: "*")'
            )
    parser.add_argument(
            '--update-working-tree',
            action='store_true',
            help='Patch working tree to apply formatting changes. Without this option formatting changes are applied to the git index, but not to working tree files.'
            )
    parser.add_argument(
            '--version', '-v',
            action='store_true',
            help='Display version of git-format-staged'
            )
    parser.add_argument(
            'command',
            nargs=argparse.REMAINDER,
            help='Shell command to format files, will run once per file. (Example: prettier --stdin)')
    args = parser.parse_args()
    command = vars(args)['command']
    version = vars(args)['version']
    if version:
        print('git-format-staged version {}'.format(VERSION))
        exit(0)
    if not command:
        print('Command is required.', file=sys.stderr)
        exit(1)

    format_staged_files(
            command=command,
            glob=vars(args)['glob'],
            update_working_tree=vars(args)['update_working_tree']
            )
